{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 394
    },
    "colab_type": "code",
    "executionInfo": {
     "elapsed": 9650,
     "status": "ok",
     "timestamp": 1585394968866,
     "user": {
      "displayName": "Anna Chesson",
      "photoUrl": "",
      "userId": "12807524964447781612"
     },
     "user_tz": -60
    },
    "id": "pfO-YeWxaO8K",
    "outputId": "a3ae7eec-7fb6-4f70-b6bf-536eff9a1d0b"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Requirement already satisfied: pypianoroll in /Users/annachesson/anaconda3/lib/python3.7/site-packages (0.5.3)\n",
      "Requirement already satisfied: pretty-midi<1.0,>=0.2.8 in /Users/annachesson/anaconda3/lib/python3.7/site-packages (from pypianoroll) (0.2.8)\n",
      "Requirement already satisfied: scipy<2.0,>=1.0.0 in /Users/annachesson/anaconda3/lib/python3.7/site-packages (from pypianoroll) (1.3.1)\n",
      "Requirement already satisfied: six<2.0,>=1.0.0 in /Users/annachesson/anaconda3/lib/python3.7/site-packages (from pypianoroll) (1.13.0)\n",
      "Requirement already satisfied: numpy<2.0,>=1.10.0 in /Users/annachesson/anaconda3/lib/python3.7/site-packages (from pypianoroll) (1.17.3)\n",
      "Requirement already satisfied: mido>=1.1.16 in /Users/annachesson/anaconda3/lib/python3.7/site-packages (from pretty-midi<1.0,>=0.2.8->pypianoroll) (1.2.9)\n",
      "Note: you may need to restart the kernel to use updated packages.\n"
     ]
    }
   ],
   "source": [
    "#install pypianoroll, if first time running notebook\n",
    "#%pip install pypianoroll\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 102
    },
    "colab_type": "code",
    "executionInfo": {
     "elapsed": 3398,
     "status": "ok",
     "timestamp": 1585394976735,
     "user": {
      "displayName": "Anna Chesson",
      "photoUrl": "",
      "userId": "12807524964447781612"
     },
     "user_tz": -60
    },
    "id": "5H4crt3mab6B",
    "outputId": "c5de7f8d-b177-4548-a26f-d18618a628e8"
   },
   "outputs": [],
   "source": [
    "#import libraries\n",
    "\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import pypianoroll"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "EJCkvGrt93YF"
   },
   "outputs": [],
   "source": [
    "#path to our folder with midi files\n",
    "#filepath = \"/Users/annachesson/code/ai_saturdays/google_collab/aisaturdays_collab/arabic_tribal_rhythms/waaHida_02.mid\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "o_RRN9f8Q-vY"
   },
   "source": [
    "# transforming to array, use pretty_midi? \n",
    "https://towardsdatascience.com/generate-piano-instrumental-music-by-using-deep-learning-80ac35cdbd2e\n",
    "\n",
    "\n",
    "to_pretty_midi(constant_tempo=None, constant_velocity=100)[source]\n",
    "Convert to a pretty_midi.PrettyMIDI instance.\n",
    "\n",
    "Notes\n",
    "\n",
    "Only constant tempo is supported by now.\n",
    "\n",
    "The velocities of the converted pianorolls are clipped to [0, 127], i.e. values below 0 and values beyond 127 are replaced by 127 and 0, respectively.\n",
    "\n",
    "Adjacent nonzero values of the same pitch will be considered a single note with their mean as its velocity.\n",
    "\n",
    "Parameters\n",
    "constant_tempo (int) – The constant tempo value of the output object. Defaults to use the first element of tempo.\n",
    "\n",
    "constant_velocity (int) – The constant velocity to be assigned to binarized tracks. Defaults to 100.\n",
    "\n",
    "Returns\n",
    "pm – The converted pretty_midi.PrettyMIDI instance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "vRI4xJIcDoWc"
   },
   "outputs": [],
   "source": [
    "#import pretty_midi library, pip install pretty_midi\n",
    "import pretty_midi"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "Gve-7lyhpjW5"
   },
   "source": [
    "#straight from tutorial. here we convert a midifile to pretty_midi directly, take the piano channel, then get the binary array\n",
    "\n",
    "midi_pretty_format = pretty_midi.PrettyMIDI(filepath)\n",
    "piano_midi = midi_pretty_format.instruments[0] # Get the piano channels\n",
    "piano_roll = piano_midi.get_piano_roll()\n",
    "whole_roll = midi_pretty_format.get_piano_roll() #fs = fs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 136
    },
    "colab_type": "code",
    "executionInfo": {
     "elapsed": 608,
     "status": "ok",
     "timestamp": 1585395085587,
     "user": {
      "displayName": "Anna Chesson",
      "photoUrl": "",
      "userId": "12807524964447781612"
     },
     "user_tz": -60
    },
    "id": "qJt4hP5ABMR2",
    "outputId": "6dae5a15-a392-4c92-e27b-2d4d78813f64"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[0., 0., 0., ..., 0., 0., 0.],\n",
       "       [0., 0., 0., ..., 0., 0., 0.],\n",
       "       [0., 0., 0., ..., 0., 0., 0.],\n",
       "       ...,\n",
       "       [0., 0., 0., ..., 0., 0., 0.],\n",
       "       [0., 0., 0., ..., 0., 0., 0.],\n",
       "       [0., 0., 0., ..., 0., 0., 0.]])"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "whole_roll"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "TC3vIobswKPz"
   },
   "source": [
    "## What is fs? ->frames per second\n",
    "After we get the array of piano roll, we convert them into dictionary. The dictionary will start from the time where the note is played. For example, in the picture above, we start from 28 (If we convert to second, assume we convert to piano_roll at 5 fps, the music start playing its notes at 5.6 s which we can get by 28 divided by 5)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "lG30IcCxtTTJ"
   },
   "source": [
    "# Questions so far\n",
    "\n",
    "1. Is there a difference, or is it necessary, to go from midi->pypiano->multitrack object->pretty_midi->binary array? Or can we just read the midi file directly with pretty_midi (midi->pretty_midi->binary array). -Update: in the end I have decided to read directly with the pretty_midi library as done in the tutorial\n",
    "\n",
    "2. the tutorial takes only the piano channel (midi_pretty_format.instruments[0]). Presumably we want to take all the instrument channels in our own training data set\n",
    "\n",
    "3. What really is frames per second? why does it matter?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "HDqXXKkc5kAZ"
   },
   "outputs": [],
   "source": [
    "#when you import the notebook it runs the some library installations necessary for it to run\n",
    "import repository"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 1000
    },
    "colab_type": "code",
    "executionInfo": {
     "elapsed": 39036,
     "status": "ok",
     "timestamp": 1585395881014,
     "user": {
      "displayName": "Anna Chesson",
      "photoUrl": "",
      "userId": "12807524964447781612"
     },
     "user_tz": -60
    },
    "id": "VbbY7HhPIu8G",
    "outputId": "5796cce0-6691-449f-ed88-4355df46ec6e"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'/Users/annachesson/code/ai_saturdays/google_collab/aisaturdays_collab/arabic_tribal_rhythms/arabic_tribal_rhythms_ZIP'"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#unzips the folder\n",
    "import zipfile\n",
    "with zipfile.ZipFile(\"arabic_tribal_rhythms_ZIP.zip\",\"r\") as zip_ref:\n",
    "    zip_ref.extractall()#where you want the file to be unzipped, I want it in the same folder?\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "vx3Xq3FZ9hB9"
   },
   "outputs": [],
   "source": [
    "#name of folder: 'maestro-v1.0.0/**/*.midi'\n",
    "\n",
    "\n",
    "def get_list_midi(folder = 'arabic_tribal_rhythms/arabic_tribal_rhythms/*.mid', seed_int = 666):\n",
    "  \"\"\"Get the list of all midi file in the folders\n",
    "  \n",
    "  Parameters\n",
    "  ==========\n",
    "  folder : str\n",
    "    The midi folder.\n",
    "  seed_int : int\n",
    "    the random seed.\n",
    "  \n",
    "  Returns\n",
    "  =======\n",
    "  The midi files\n",
    "  \n",
    "  \"\"\"\n",
    "  list_all_midi = glob.glob(folder)\n",
    "  seed(seed_int)\n",
    "  shuffle(list_all_midi)\n",
    "  return list_all_midi\n",
    "\n",
    "list_all_midi = get_list_midi()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "executionInfo": {
     "elapsed": 847,
     "status": "ok",
     "timestamp": 1585396063421,
     "user": {
      "displayName": "Anna Chesson",
      "photoUrl": "",
      "userId": "12807524964447781612"
     },
     "user_tz": -60
    },
    "id": "AM5FntZBFF6X",
    "outputId": "1d6d5db4-a5f8-4e0a-ef76-93955189f517"
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "98"
      ]
     },
     "execution_count": 48,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(list_all_midi)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "hKbbpPlECBM5"
   },
   "source": [
    "# The following function from notetokenizer.py creates a dictionary of notes from the pianoroll array\n",
    "\n",
    "def generate_dict_time_notes(list_all_midi, batch_song = 16, start_index=0, fs=30, use_tqdm=True):\n",
    "    \"\"\" Generate map (dictionary) of music ( in index ) to piano_roll (in np.array)\n",
    "\n",
    "    Parameters\n",
    "    ==========\n",
    "    list_all_midi : list\n",
    "        List of midi files\n",
    "    batch_music : int\n",
    "      A number of music in one batch\n",
    "    start_index : int\n",
    "      The start index to be batched in list_all_midi\n",
    "    fs : int\n",
    "      Sampling frequency of the columns, i.e. each column is spaced apart\n",
    "        by ``1./fs`` seconds.\n",
    "    use_tqdm : bool\n",
    "      Whether to use tqdm or not in the function\n",
    "\n",
    "    Returns\n",
    "    =======\n",
    "    dictionary of music to piano_roll (in np.array)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "eYW5TLpIDXLa"
   },
   "outputs": [],
   "source": [
    "from repository import generate_dict_time_notes, generate_input_and_target, process_notes_in_song, generate_batch_song, NoteTokenizer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "Ib_3S7zpDsje"
   },
   "outputs": [],
   "source": [
    "from time import sleep"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 453
    },
    "colab_type": "code",
    "executionInfo": {
     "elapsed": 1028,
     "status": "error",
     "timestamp": 1585397565706,
     "user": {
      "displayName": "Anna Chesson",
      "photoUrl": "",
      "userId": "12807524964447781612"
     },
     "user_tz": -60
    },
    "id": "CMyyt2nZDuAs",
    "outputId": "5a1ea689-9a9f-4f5b-a0d2-84e64b7b8cf7"
   },
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "165d62d4c4e34636a588e85af2726fa0",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=1), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    }
   ],
   "source": [
    "#basically all this tqdm does in the end is display these progress bars.... fml\n",
    "from tqdm import notebook as tqdm\n",
    "with tqdm.tqdm(range(1)) as pbar:\n",
    "  pass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 303
    },
    "colab_type": "code",
    "executionInfo": {
     "elapsed": 670,
     "status": "error",
     "timestamp": 1585397091702,
     "user": {
      "displayName": "Anna Chesson",
      "photoUrl": "",
      "userId": "12807524964447781612"
     },
     "user_tz": -60
    },
    "id": "J9-te5vNCLH_",
    "outputId": "0444f88f-ee79-46f9-920d-844029e1e552"
   },
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "f8003dc7310a48b28940df89ad11994c",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=16), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    }
   ],
   "source": [
    "dictionary = generate_dict_time_notes(list_all_midi, batch_song = 16, start_index=0, fs=30, use_tqdm=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "181Ai4Xq_gh4"
   },
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "67dd0703f574422fbbc31417a0c58afe",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=98), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "1\n"
     ]
    }
   ],
   "source": [
    "# # Sample 100 midi files from the datasets\n",
    "# These midi files will be used to train the neural network\n",
    "\n",
    "# In[6]:\n",
    "\n",
    "\n",
    "# Get 200 midis file from the datasets.. \n",
    "\n",
    "sampled_200_midi = list_all_midi[0:100]  \n",
    "\n",
    "\n",
    "# We create a map of note -> index here using NoteTokenizer that we've defined before.  \n",
    "# This object will be used to transform the list of notes to be ready for the input of Neural Network\n",
    "\n",
    "# In[7]:\n",
    "\n",
    "\n",
    "batch = 1\n",
    "start_index = 0\n",
    "note_tokenizer = NoteTokenizer()\n",
    "\n",
    "for i in tqdm.tqdm(range(len(sampled_200_midi))):\n",
    "    dict_time_notes = generate_dict_time_notes(sampled_200_midi, batch_song=1, start_index=i, use_tqdm=False, fs=5)\n",
    "    full_notes = process_notes_in_song(dict_time_notes)\n",
    "    for note in full_notes:\n",
    "        note_tokenizer.partial_fit(list(note.values()))\n",
    "   \n",
    "\n",
    "\n",
    "# In[8]:\n",
    "\n",
    "\n",
    "note_tokenizer.add_new_note('e') # Add empty notes\n",
    "\n",
    "\n",
    "# In[9]:\n",
    "\n",
    "\n",
    "unique_notes = note_tokenizer.unique_word\n",
    "print(unique_notes)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "colab": {
   "authorship_tag": "ABX9TyMmbkYciF6ma05gIpY2t4Y9",
   "name": "midi_2_pianoroll.ipynb",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
